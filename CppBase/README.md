<!--
 * @Author: EST 363023987@qq.com
 * @Date: 2025-05-30 15:34:30
 * @LastEditors: EST 363023987@qq.com
 * @LastEditTime: 2025-06-04 22:22:22
-->
- [变量和输入输出](#变量和输入输出)
  - [变量](#变量)
    - [变量的理解](#变量的理解)
    - [变量的定义与初始化](#变量的定义与初始化)
    - [命名规则](#命名规则)
    - [数据类型的分类](#数据类型的分类)
  - [输入输出](#输入输出)
- [类型转换](#类型转换)
- [作用域](#作用域)
- [内存的使用划分](#内存的使用划分)
- [生成过程](#生成过程)
- [复合类型](#复合类型)
  - [类型说明](#类型说明)
  - [引用](#引用)
  - [左值引用与右值引用](#左值引用与右值引用)
  - [指针](#指针)
    - [指针基础](#指针基础)
    - [指针运算](#指针运算)
  - [const关键字](#const关键字)
  - [constexpr和常量表达式](#constexpr和常量表达式)
- [类型推导和类型别名](#类型推导和类型别名)
  - [类型别名](#类型别名)
  - [类型推导](#类型推导)
    - [auto](#auto)
    - [decltype类型指示符](#decltype类型指示符)


# 变量和输入输出
## 变量
### 变量的理解
进行计算的两个必要条件:
- `数据`
- `要进行的操作`

编程是要进行不同数据的`统一操作`,所以数据不能是定量而是`变量`,通过抽象为符号的形式而不去关心`具体的`数据值.

定量是实际的数据要具有`合法性`,例如:0作为除数就是非法操作

计算机只能通过高低电平(`0/1 一位 bit`)存储二进制,将8个这样的位组成一个最小的存储单元(`字节 byte`),可以表示从`0000 0000`到`1111 1111`个数字.

一个字节表示只能表示256个数,很显然这个大小是不够代表所有的数据,所以通过增加使用的存储单元数量来增加数字的表示范围.

计算机存储数据不能是随机大小的连续空间,这样对于计算机硬件的使用效率太低了, 所以根据数据的不同抽象出了数据类型,来表示对应的连续`空间的大小`和这片连续空间的`使用方式`.

有了以上的说明来解释一下变量,在C++中变量是用来存储数据值的一种实体。每个变量都有一个类型，这个类型决定了变量可以存储的数据的种类以及变量在内存中所占的空间大小。

### 变量的定义与初始化
```cpp
// 例如
int a{10};
```
上述示例中: 
- `int`表示申请4个连续的字节
- `{10}`申请的连续四个字节里边填入的数据
- `a`抽象的表示4个连续字节和这片空间的使用方式
- 通过`a`可以重复使用这片空间

### 命名规则
在C++中，变量名可以包含字母、数字和下划线(_)，但不能以数字开头。此外，C++是大小写敏感的，因此age和Age被视为两个不同的变量。

### 数据类型的分类
C++支持多种基本数据类型，包括
- 整型(int、short、long、long long)
- 浮点型(float、double、long double)
- 字符型(char)
- 布尔型(bool)
- 枚举(enum)
- 结构体(struct)
- 联合体(union)
- 类(class)

来看一下一些常见类型申请到的内存大小
```cpp
template<typename T>
void Print_Size(const std::string& str)
{
    std::cout<<str<<" size : "<<sizeof(T)<<"\n";
}

void Test::_type_sizeof()
{
    Print_Size<int>("int");
    Print_Size<short>("short");
    Print_Size<long>("long");
    Print_Size<char>("char");
    Print_Size<double>("double");
    Print_Size<float>("float");
    Print_Size<char>("char");
}
```
输出:
```cpp
int size : 4
short size : 2
long size : 4
char size : 1
double size : 8
float size : 4
char size : 1
```
## 输入输出
通过将参与的操作的数据抽象为了变量编写好了一系列复杂的操作,当要进行这个操作的时候需要对抽象出来的变量实例化也就是给出定量的数据`输入`,经过一系列的复杂运算得到一个结果`输出`,为了更加形象的看出方向性:
- `>>`输入运算符
- `<<`输出运算符

在C++中，输出通常是通过标准输出流`std::cout`来完成的。std::cout 是C++标准库中的一个对象，它代表标准输出设备，通常是屏幕。为了使用 std::cout 来输出数据，你需要包含头文件 <iostream> 上述例子已经使用了输出运算符。

# 类型转换
数据的操作并不会严格规定数据类型所以存在着两种数据转换方向:
- `大内存数据向小内存数据转换`
- `小内存数据向大内存数据转换`

一般大内存能够兼容的表示小内存数据所以C++提供小向大的自动转换`隐式类型转换`,而大内存向小内存转换的时候是无法兼容的会舍弃一些内容(丢失精度等)`强制类型转换`

# 作用域

在C++中，变量作用域（Scope）指的是程序中变量可以被访问的代码区域。作用域决定了变量的生命周期和可见性。为了保证数据的安全和内存的使用效率:限制可以访问的权限和内存资源销毁规则

常见的几种作用域:

1. 全局作用域：在函数外部声明的变量具有全局作用域。它们可以在程序的任何地方被访问，但通常建议在需要时才使用全局变量，因为它们可能导致代码难以理解和维护。
2. 局部作用域：在函数内部、代码块（如if语句、for循环等）内部声明的变量具有局部作用域。它们只能在声明它们的代码块内被访问。一旦离开该代码块，这些变量就不再可见。
3. 命名空间作用域：在命名空间中声明的变量（实际上是实体，如变量、函数等）具有命名空间作用域。它们只能在相应的命名空间内被直接访问，但可以通过使用命名空间的名称作为前缀来从外部访问。
4. 类作用域：在类内部声明的成员变量和成员函数具有类作用域。成员变量和成员函数可以通过类的对象来访问，或者在某些情况下（如静态成员）可以通过类名直接访问。
5. 块作用域：这是局部作用域的一个特例，指的是由大括号{}包围的代码块内部声明的变量。这些变量只能在该代码块内被访问

# 内存的使用划分

在C++中，内存存储通常可以大致分为几个区域，这些区域根据存储的数据类型、生命周期和作用域来划分。这些区域主要包括：
1. 代码区（Code Segment/Text Segment）：
  - 存储程序执行代码（即机器指令）的内存区域。这部分内存是共享的，只读的，且在程序执行期间不会改变。
  - 举例说明：当你编译一个C++程序时，所有的函数定义、控制结构等都会被转换成机器指令，并存储在代码区。
2. 全局/静态存储区（Global/Static Storage Area）：
  - 存储全局变量和静态变量的内存区域。这些变量在程序的整个运行期间都存在，但它们的可见性和生命周期取决于声明它们的作用域。
  - 举例说明：全局变量（在函数外部声明的变量）和静态变量（使用static关键字声明的变量，无论是在函数内部还是外部）都会存储在这个区域。
3. 栈区（Stack Segment）：
  - 存储局部变量、函数参数、返回地址等的内存区域。栈是一种后进先出（LIFO）的数据结构，用于存储函数调用和自动变量。
  - 举例说明：在函数内部声明的变量（不包括静态变量）通常存储在栈上。当函数被调用时，其参数和局部变量会被推入栈中；当函数返回时，这些变量会从栈中弹出，其占用的内存也随之释放。
4. 堆区（Heap Segment）：
  - 由程序员通过动态内存分配函数（如new和malloc）分配的内存区域。堆区的内存分配和释放是手动的，因此程序员需要负责管理内存，以避免内存泄漏或野指针等问题。
  - 举例说明：当你使用new操作符在C++中动态分配一个对象或数组时，分配的内存就来自堆区。同样，使用delete操作符可以释放堆区中的内存。
5. 常量区（Constant Area）：
  - 存储常量（如字符串常量、const修饰的全局变量等）的内存区域。这部分内存也是只读的，且通常在程序执行期间不会改变。
  - 举例说明：在C++中，使用双引号括起来的字符串字面量通常存储在常量区。此外，使用const关键字声明的全局变量，如果其值在编译时就已确定，也可能存储在常量区。

# 生成过程
C++程序的编译过程是一个相对复杂但有序的过程，它涉及将高级语言（C++）代码转换为机器可以执行的低级指令。在这个过程中，通常会生成几个中间文件，包括.i（预处理文件）、.s（汇编文件）和.o（目标文件或对象文件）。下面是这个过程的详细解释：
1. 预处理（Preprocessing）
- 输入：C++源代码文件（通常以.cpp或.cxx为后缀）。
- 处理：预处理器（通常是cpp）读取源代码文件，并对其进行宏展开、条件编译、文件包含（#include）等处理。
- 输出：生成预处理后的文件，通常具有.i后缀（尽管这个步骤可能不是所有编译器都会自动生成.i文件，或者可能需要特定的编译器选项来生成）。
2. 编译（Compilation）
- 输入：预处理后的文件（如果有的话，否则直接是源代码文件）。
- 处理：编译器（如g++、clang++等）将预处理后的文件或源代码文件转换为汇编语言代码。这个步骤是编译过程的核心，它执行词法分析、语法分析、语义分析、中间代码生成、代码优化等任务。
- 输出：生成汇编文件，通常具有.s或.asm后缀。
3. 汇编（Assembly）
- 输入：汇编文件。
- 处理：汇编器（如as、gas等）将汇编语言代码转换为机器语言指令（即目标代码），但这些指令仍然是针对特定架构的，并且尚未被链接成可执行文件。
- 输出：生成目标文件（或对象文件），通常具有.o、.obj或.out后缀。
4. 链接（Linking）
- 输入：一个或多个目标文件，以及可能需要的库文件（如C++标准库）。
- 处理：链接器（如ld、lld等）将目标文件和库文件合并成一个可执行文件或库文件。在这个过程中，链接器会解决外部符号引用（即函数和变量的调用），并将它们链接到正确的地址。
- 输出：生成可执行文件（在Unix-like系统中通常是.out、.exe或没有特定后缀，在Windows系统中是.exe）。

# 复合类型

## 类型说明
复合类型是由内置类型或其他复合类型组合而成的类型，主要包括以下几种：

- 数组（Array） :  一组相同类型的数据元素，可以通过索引访问。
- 结构体（Struct） :  一种用户定义的数据类型，可以包含不同类型的数据成员。
- 联合体（Union） :  与结构体类似，但所有成员共享同一内存位置，只有一个成员可以在任何给定时间存储值。
- 枚举（Enum） :  一种用户定义的类型，用于定义一组命名的整型常量。
- 类（Class） :  C++的面向对象编程特性，允许定义包含数据和成员函数的复杂数据类型。
- 指针（Pointer） :  指向其他类型的内存地址，可以用来动态分配内存和实现复杂的数据结构。
- 引用（Reference） :  对现有变量的别名，提供了对变量的另一种访问方式。
## 引用
C++ 中的引用类型是一种复合类型，它是对另一个变量的别名。在C++中使用引用，可以让我们直接访问和操作另一个变量的内存地址，而不需要通过指针的解引用操作。引用在语法上比指针更简洁，且在许多情况下更安全。

引用的出现解决了跨作用域使用变量只能通过间接的使用内存首地址,同时使用约束性不强的类型指针进行传递的场景减少了内存使用同时增大了类型约束

![定义两个变量](./Image/定义两个变量.png)

图中表示了一个变量在不同作用域之间的的传递过程,将a作为形参的b的实例化内容进行拷贝一份具有自己独立的空间和内容

![传递引用.png](./Image/传递引用.png)

图中是使用引用的方式对变量进行传递,使用引用是在语言层面上对内存地址加上内存大小的再获取和抽象化,也就代表了引用具有一下三个特性:
1. 必须初始化：引用在创建时必须被初始化，它必须指向某个已存在的对象。
2. 一旦绑定，不可改变：引用一旦被初始化后，它将一直保持与其初始对象的绑定，不能改变为另一个对象的引用。
3. 没有空引用：引用必须指向某个对象，不能存在空引用。

注意一下内容:
- 引用主要用于函数参数和返回值，以及类的成员变量等场景，以提供对原始数据的直接访问，从而提高程序的效率和可读性。
- 引用可以是const的，这表示你不能通过引用来修改它所指向的对象的值。
- 引用在内部实现上通常是通过指针来实现的，但它们在语法和用途上与指针有显著的不同。引用提供了更直观、更安全的访问方式。
## 左值引用与右值引用
在C++中，左值（lvalue）和右值（rvalue）是表达式的两种基本分类，它们决定了表达式的结果在内存中的位置和状态。左值通常指的是具有持久状态的对象，它们有`明确的内存地址`，可以被多次赋值。而右值通常是临时的、没有持久状态的值，它们通常`没有内存地址`，或者其内存地址在`表达式结束后就变得无效`。

C++11引入了右值引用（rvalue reference），用T&&表示，作为对左值引用（lvalue reference，用T&表示）的补充。这一特性极大地增强了C++的表达能力，特别是在资源管理和性能方面。

右值引用是C++11新增的特性，它允许我们为右值（即临时对象或即将被销毁的对象）创建一个引用。这样，我们就可以对右值进行更复杂的操作，比如移动语义（move semantics）。
```cpp
std::string foo()
{
  return std::string("rvalue");
}
int main()
{
  std::string&& r = foo();
}
```
上述代码就是一个函数返回了一个右值,明确的知道他的内容但是不知道他具体的内存地址

右值引用的引入主要是为了支持`移动语义`（move semantics），它允许我们在对象被销毁前“窃取”其资源（如动态分配的内存、文件句柄等），而不是进行深拷贝。这可以显著提高性能，特别是在处理大型对象或容器时。
`完美转发`（perfect forwarding）是另一个与右值引用相关的概念，它允许我们将参数原封不动地传递给另一个函数，无论是左值还是右值。这通过模板和std::forward函数实现。

总结:
- 左值引用（T&）是C++98就有的特性，用于为已存在的对象创建别名。
- 右值引用（T&&）是C++11新增的特性，用于为右值（即临时对象）创建引用，支持移动语义和完美转发等高级特性。
- 右值引用的主要用途不是直接绑定到字面量或简单的右值表达式上，而是在函数参数和返回值中，以实现更高效的资源管理和更灵活的代码编写方式。

## 指针
### 指针基础
在C++中，指针是一种特殊的变量，它存储的是另一个变量的内存地址，而不是数据本身。通过使用指针，我们可以直接访问和操作内存中的数据。指针也叫做地址。

指针其实就是用一个整数表示一个变量的首地址,通过`&`将一个变量抽象为符号的内存地址还原回一个具体的整数

```cpp
// 变量地址 = &变量名
int a = 10;
int* pa = &a;
```

指针只能代表一片连续空间的首地址,至于连续多少个内存空间,这个连续内存空间的解释方式就要由`指针类型`来决定,例如:int* 就代表这个地址是int类型的解释方式和连续空间,但是所有地址的表示方式在同一个电脑上是统一的,所以指针类型是一个弱类型,可以被`任意解释`

指针的值（即地址）应属下列4种状态之一：
1. 指向一个对象。
2. 指向紧邻对象所占空间的下一个位置。
3. 空指针，意味着指针没有指向任何对象。
4. 无效指针，也就是上述情况之外的其他值。
5. 
试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。
访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。
尽管第2种和第3种形式的指针是有效的，但其使用同样受到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。如果这样做了，后果也无法预计。

### 指针运算
每次对一个具体类型的指针进行增加减少某个数量的操作,代表向这个指针表示的具体整数增加 n*sizeof(type)的整数值

## const关键字
`const `是 C++ 关键字，用于指示变量的值不可修改。通过使用 const，可以提高代码的安全性与可读性，防止无意中修改变量的值。

```cpp
const int a = 10;
const int b = a;
int c = b;
```

`const `修饰的变量在编译时会被视为只读，尝试修改其值会导致编译错误。此外，编译器可能会对 const 变量进行优化，如将其存储在只读内存区域。默认状态下，const对象仅在文件内有效

## constexpr和常量表达式
常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：
```cpp
int GetSize(){
    return 20;
}

//20是一个常量表达式
constexpr int mf = 20;
//mf+1是一个常量表达式
constexpr int limit = mf + 10;
//错误，GetSize()不是一个常量表达式，需要运行才能返回
//constexpr int sz = GetSize();
```

constexpr 的核心思想是在编译期间而非运行时执行计算，这带来了多重优势：
- 性能提升：消除运行时计算开销
- 类型安全：编译器验证计算正确性
- 元编程能力：支持复杂的编译时逻辑
- 错误早发现：编译期捕获潜在错误

# 类型推导和类型别名

顶层const:指的抽象成变量名的地址无法被改变
底层const:连续的内存空间无法被改变

## 类型别名
类型别名（type alias）是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，还有助于程序员清楚地知道使用该类型的真实目的。
有两种方法可用于定义类型别名。传统的方法是使用关键字typedef：
```cpp
//wages 是double的同义词
typedef double wages;
//base是double的同义词,p是double*的同义词
typedef wages base, *p;
```
新标准规定了一种新的方法，使用别名声明（alias declaration）来定义类型的别名：
```cpp
//64位整型
using int64_t = long long;
```

## 类型推导
### auto
编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。
然而要做到这一点并非那么容易，有时甚至根本做不到。
为了解决这个问题，C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。
和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值：
```cpp
//计算求和
int age1 = 20;
int age2 = 35;
auto age_add = age1+age2;
```
auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：
```cpp
{
    int i = 0, &r = i;
    // a是一个整数，类型是r所引用的类型
    auto a = r;
    // cr是一个常量引用，ci是int类型的常量
    const int ci = i, &cr = ci;
    // b是一个整数，ci顶层const被忽略了
    auto b = ci;
    // c是一个整数，cr是ci的别名，ci本身是一个顶层const
    auto c = cr;
    // d 是一个整型指针，i是整型
    auto d = &i;
    // e是一个指向整数常量的指针，对常量对象取地址是一种底层const
    auto e = &ci;
}
```
如果希望推断出的auto类型是一个顶层const，需要明确指出：
```cpp
//顶层const可显示指定,f是一个const int类型
const auto f = ci;
```
### decltype类型指示符
有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。
为了满足这一要求，C++11新标准引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：
```cpp
decltype(f()) sum = x; //sum的类型就是函数f的返回值的类型
```
编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。

decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：
```cpp
const int ci = 0, &cj = ci;
//x是const int类型
decltype(ci) x = 0;
//y是一个const int&类型，y绑定到x
decltype(cj) y = x;
//错误，z是一个引用,引用必须初始化
//decltype(cj) z;
```
因为cj是一个引用，decltype（cj）的结果就是引用类型，因此作为引用的z必须被初始化。
需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外

